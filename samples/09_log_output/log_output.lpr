program log_output;

{$mode objfpc}{$H+}

{ Sample 09 Log Output                                                         }
{                                                                              }
{  How to output logging information to a console window                       }
{                                                                              }
{  Ultibo supports logging to the console, a file, a UART or to the network    }
{                                                                              }
{  The project simply calls a "main" function in the C/C++ project and passes  }
{  all command line arguments to it. The main function can then do anything it }
{  requires by calling Ultibo API functions, standard C library funtions or    }
{  other libraries.                                                            }
{                                                                              }
{  Note that you can call your main function anything you like except main.    }
{  Free Pascal has an internal alias of MAIN that refers to the begin/end      }
{  section of the project file below (also known as PASCALMAIN).               }
{                                                                              }
{  You are also not limited to just calling a single main function from the    }
{  Free Pascal project, you can include other Free Pascal functionality such   }
{  as creating additional threads and including optional units. You can also   }
{  call directly to multiple functions within your C/C++ project from multiple }
{  threads which can be created here or created inside you C/C++ project.      }
{                                                                              }
{  To compile the project use the template Makefile from the command line.     }
{                                                                              }
{  Once compiled copy the kernel image file to an SD card along with the       }
{  firmware files and use it to boot your Raspberry Pi.                        }

{Include the standard Ultibo units}
uses
 {$IFDEF RPIB}
  RaspberryPi,     {Include RaspberryPi to make sure all standard drivers are available}
  {$DEFINE BOARD_DEFINED}
 {$ENDIF}
 {$IFDEF RPI2B}
  RaspberryPi2,    {Include RaspberryPi2 to make sure all standard drivers are available}
  {$DEFINE BOARD_DEFINED}
 {$ENDIF}
 {$IFDEF RPI3B}
  RaspberryPi3,    {Include RaspberryPi3 to make sure all standard drivers are available}
  {$DEFINE BOARD_DEFINED}
 {$ENDIF}
 {$IFDEF RPI4B}
  RaspberryPi4,    {Include RaspberryPi4 to make sure all standard drivers are available}
  {$DEFINE BOARD_DEFINED}
 {$ENDIF}
 {$IFDEF QEMUVPB}
  QEMUVersatilePB, {Include QEMUVersatilePB to make sure all standard drivers are available}
  {$DEFINE BOARD_DEFINED}
 {$ENDIF}
 {$IFNDEF BOARD_DEFINED}
  RaspberryPi2,    {Include RaspberryPi2 if nothing else was defined (eg Building from Lazarus)}
 {$ENDIF}
 API,              {Include the API unit to export the Ultibo API}
 GlobalTypes,
 GlobalConfig,
 Platform,
 Threads,
 Syscalls,         {Include the Syscalls unit for standard C library support}
 UltiboUtils;

{Link our C/C++ object files by including the autogenerated include files}
{$INCLUDE __linklib.inc}
{$INCLUDE __link.inc}

{Import the main function of the project so we can call it from Ultibo}
function APIMain(argc: int; argv: PPChar): int; cdecl; external name 'apimain';

{Variables to hold argc and argv to pass to our C/C++ project}
var
 argc:int;
 argv:PPChar;

begin
 {Because console logging is disabled by default we need to enable it first.

  This can also be done using the command line parameter CONSOLE_REGISTER_LOGGING=1
  in the cmdline.txt file on the SD card.

  }
 CONSOLE_REGISTER_LOGGING:=True;

 {Allocate the command line arguments}
 argv:=AllocateCommandLine(SystemGetCommandLine,argc);

 {Call the "main" function of our C/C++ project}
 APIMain(argc,argv);

 {Release the command line}
 ReleaseCommandLine(argv);

 {Halt the main thread if we return}
 ThreadHalt(0);
end.